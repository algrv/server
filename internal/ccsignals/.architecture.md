# Content Protection Architecture Overview Using CC Signals

Hybrid behavioral + fingerprint-based detection system for blocking AI agent requests containing CC-licensed content.

---

## System Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                         CLIENT (Browser)                            │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────────┐  │
│  │  Editor UI  │───▶│ Event Hook  │───▶│ WebSocket Client        │  │
│  └─────────────┘    └─────────────┘    └───────────┬─────────────┘  │
└────────────────────────────────────────────────────┼────────────────┘
                                                     │
                                                     ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         SERVER                                      │
│  ┌─────────────────┐    ┌─────────────────┐    ┌────────────────┐   │
│  │ Session Manager │───▶│ Detection Engine │───▶│ Lock Manager   │  │
│  └─────────────────┘    └────────┬────────┘    └────────────────┘   │
│                                  │                                  │
│                                  ▼                                  │
│                         ┌─────────────────┐                         │
│                         │ In-Memory Index │ ◀── loaded from         │
│                         │   (LSH + SimHash)│     user_strudels      │
│                         └─────────────────┘                         │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Core Components

| Component            | Responsibility                                                        |
| -------------------- | --------------------------------------------------------------------- |
| **Event Hook**       | Intercepts paste events, calculates content delta, emits to websocket |
| **Session Manager**  | Tracks session state, maintains audit log of content changes          |
| **Detection Engine** | Evaluates paste size, runs fingerprint matching when triggered        |
| **Fingerprint DB**   | Stores SimHash signatures of protected works                          |
| **Lock Manager**     | Enforces and releases session locks based on edit distance            |

---

## Detection Flow

```
                              ┌──────────────┐
                              │ Code Update  │
                              └──────┬───────┘
                                     │
                                     ▼
                          ┌────────────────────┐
                          │ Size > threshold?  │
                          │ (200+ chars or     │
                          │  50+ lines delta)  │
                          └─────────┬──────────┘
                                    │
                       ┌────────────┴────────────┐
                       │                         │
                       ▼                         ▼
                      NO                        YES
                       │                         │
                       ▼                         ▼
                  ┌─────────┐       ┌────────────────────────┐
                  │  Allow  │       │ Check legitimate source │
                  └─────────┘       └───────────┬────────────┘
                                                │
                          ┌─────────────────────┼─────────────────────┐
                          │                     │                     │
                          ▼                     ▼                     ▼
                   ┌────────────┐       ┌────────────┐       ┌────────────┐
                   │ User owns  │       │ Public +   │       │ Fingerprint│
                   │ content?   │       │ allows AI? │       │ match?     │
                   └─────┬──────┘       └─────┬──────┘       └─────┬──────┘
                         │                    │                    │
            ┌────────────┴───┐    ┌───────────┴───┐    ┌───────────┴───────┐
            │                │    │               │    │                   │
            ▼                ▼    ▼               ▼    ▼                   ▼
           YES              NO  YES              NO   MATCH              NO MATCH
            │                │    │              │   (no-ai)               │
            ▼                │    ▼              │     │                   │
       ┌─────────┐           │  ┌─────────┐      │     │                   │
       │  Allow  │           │  │  Allow  │      │     │                   │
       └─────────┘           │  └─────────┘      │     │                   │
                             │                   │     │                   │
                             └───────────────────┴────-┴───────────────────┘
                                                 │
                                                 ▼
                                        ┌────────────────┐
                                        │ LOCK SESSION   │
                                        │ Store baseline │
                                        │ for edit check │
                                        └────────────────┘
```

**Key behavior:** Large delta with no legitimate source = LOCK (protects against external paste)

---

## Lock Release Flow

```
                         ┌─────────────────────┐
                         │ Session is locked   │
                         │ Original paste      │
                         │ stored as baseline  │
                         └──────────┬──────────┘
                                    │
                                    ▼
                         ┌─────────────────────┐
                         │ User edits content  │
                         │ (any keystroke)     │
                         └──────────┬──────────┘
                                    │
                                    ▼
                         ┌─────────────────────┐
                         │ Calculate edit      │
                         │ distance from       │
                         │ original paste      │
                         └──────────┬──────────┘
                                    │
                                    ▼
                         ┌─────────────────────┐
                         │ Distance ≥ 30%?     │
                         └──────────┬──────────┘
                                    │
                       ┌────────────┴────────────┐
                       │                         │
                       ▼                         ▼
                      NO                        YES
                       │                         │
                       ▼                         ▼
               ┌───────────────┐        ┌───────────────┐
               │ Remain locked │        │ Release lock  │
               │ Agent blocked │        │ Agent enabled │
               └───────────────┘        └───────────────┘
```

---

## Fingerprinting Strategy

### Protected Content Ingestion

```
Creator saves work + selects CC license
              │
              ▼
    ┌─────────────────────┐
    │ Normalize text      │
    │ • lowercase         │
    │ • strip punctuation │
    │ • collapse spaces   │
    └──────────┬──────────┘
               │
               ▼
    ┌─────────────────────┐
    │ Generate shingles   │
    │ (3-word windows)    │
    └──────────┬──────────┘
               │
               ▼
    ┌─────────────────────┐
    │ Compute SimHash     │
    │ (64-bit)            │
    └──────────┬──────────┘
               │
               ▼
    ┌─────────────────────┐
    │ Store in DB with    │
    │ • work_id           │
    │ • creator_id        │
    │ • cc_signal         │
    │ • fingerprint       │
    └─────────────────────┘
```

### Query Matching (with LSH)

```
fingerprint_query(content):
    hash ← simhash(normalize(content))

    // LSH: only check candidates in shared buckets
    candidates ← lsh_index.get_candidates(hash)

    for each candidate in candidates:
        distance ← hamming_distance(hash, candidate.fingerprint)
        if distance ≤ SIMILARITY_THRESHOLD:
            return MATCH, candidate.metadata

    return NO_MATCH
```

**Threshold guidance:**

- `SIMILARITY_THRESHOLD` = 10 bits (of 64) catches near-duplicates (~84% similarity)
- Lower = stricter (more false negatives)
- Higher = looser (more false positives)

---

## Session State Machine

```
                    ┌───────────────────┐
                    │                   │
        ┌───────────│      IDLE         │◀──────────────┐
        │           │                   │               │
        │           └─────────┬─────────┘               │
        │                     │                         │
        │         large delta detected                  │
        │                     │                         │
        │                     ▼                         │
        │           ┌───────────────────┐               │
        │           │                   │               │
        │           │    EVALUATING     │               │
        │           │                   │               │
        │           └─────────┬─────────┘               │
        │                     │                         │
        │        ┌────────────┴────────────┐            │
        │        │                         │            │
        │   legitimate                no legitimate     │
        │   source found              source found      │
        │        │                         │            │
        │        │                         ▼            │
        │        │               ┌───────────────────┐  │
        │        │               │                   │  │
        │        │               │      LOCKED       │  │
        │        │               │                   │  │
        │        │               └─────────┬─────────┘  │
        │        │                         │            │
        │        │               sufficient edits        │
        │        │                         │            │
        └────────┴─────────────────────────┴────────────┘
```

---

## Edit Distance Calculation

For lock release, measure how much the content has diverged from the original paste.

```
edit_distance_ratio(original, current):
    distance ← levenshtein(original, current)
    return distance / length(original)
```

**Release threshold:** `0.3` (30% character-level change)

---

## Storage Schema

### Fingerprint Index (In-Memory)

Fingerprints are computed at startup from `user_strudels` where `cc_signal = 'no-ai'` and stored in an in-memory LSH index. No separate database table is needed.

```
IndexedFingerprintStore
├── index      *LSHIndex           -- LSH buckets for O(1) lookup
└── hasher     *SimHasher          -- Computes 64-bit fingerprints

FingerprintRecord (in-memory)
├── ID              string
├── Fingerprint     uint64         -- 64-bit SimHash
├── WorkID          string         -- strudel ID
├── CreatorID       string         -- user ID
├── CCSignal        CCSignal       -- no-ai (only no-ai strudels are indexed)
├── Content         string         -- original code
└── ContentLength   int
```

**Lifecycle:**

- **Startup**: Load all no-ai strudels from `user_strudels`, compute fingerprints, insert into LSH index
- **Create/Update strudel**: If `cc_signal = no-ai`, add to index via `IndexStrudel()`
- **Delete strudel**: Remove from index via `RemoveStrudel()`

### Session Lock Store (Redis)

```
paste_lock:{sessionID}     → "1" (with TTL)
paste_baseline:{sessionID} → <code at paste time> (with TTL)
```

---

## LSH (Locality-Sensitive Hashing)

LSH enables O(1) average-case fingerprint lookup by bucketing similar fingerprints together.

### Structure

```
4 bands × 16 bits each = 64 bits total

buckets[band_index][band_value] → [record_id1, record_id2, ...]
```

### Query Algorithm

```
query(fingerprint):
    bands ← extract_bands(fingerprint)  // 4 × 16-bit values
    candidates ← {}

    for i, band_value in enumerate(bands):
        candidates.add_all(buckets[i][band_value])

    results ← []
    for candidate_id in candidates:
        record ← records[candidate_id]
        distance ← hamming_distance(fingerprint, record.fingerprint)
        if distance ≤ threshold:
            results.append(record, distance)

    return results
```

### Time Complexity

| Operation              | Without LSH | With LSH             |
| ---------------------- | ----------- | -------------------- |
| Fingerprint lookup     | O(n)        | O(candidates) ≈ O(1) |
| Similar content search | O(n)        | O(bucket_size)       |

---

## Threat Model

### What This Catches

| Attack                                 | Caught? |
| -------------------------------------- | ------- |
| Direct copy-paste                      | ✓       |
| Copy-paste with minor edits            | ✓       |
| Copy-paste in chunks (above threshold) | ✓       |

### What This Misses

| Attack                     | Why                        |
| -------------------------- | -------------------------- |
| Small chunk pasting        | Below size threshold       |
| Simulated keystrokes       | No paste event fired       |
| Pre-paraphrased content    | Fingerprint diverges       |
| Direct API calls           | Bypasses frontend entirely |
| DOM injection via devtools | No paste event fired       |
| Content not in corpus      | Nothing to match against   |

---

## Implementation Status

### ✓ Implemented

| Feature                | File                  | Description                                      |
| ---------------------- | --------------------- | ------------------------------------------------ |
| Behavioral detection   | `detector.go`         | Large delta detection, lock/unlock logic         |
| Levenshtein distance   | `levenshtein.go`      | Edit distance for unlock threshold               |
| SimHash fingerprinting | `simhash.go`          | 64-bit fingerprint generation                    |
| LSH indexing           | `lsh.go`              | O(1) similarity search + IndexedFingerprintStore |
| Redis lock store       | `redis_store.go`      | Production lock storage with TTL                 |
| Memory lock store      | `memory_store.go`     | In-memory LockStore for testing                  |
| Strudel validator      | `algorave_adapter.go` | ContentValidator for strudels (ownership checks) |

### Unit Tests

All components have comprehensive test coverage:

- `detector_test.go`
- `lsh_test.go`
- `simhash_test.go`
- `levenshtein_test.go`
- `types_test.go`

---

## Configuration

```go
config := ccsignals.Config{
    PasteDeltaThreshold: 200,   // chars to trigger detection
    PasteLineThreshold:  50,    // lines to trigger detection
    UnlockThreshold:     0.30,  // 30% edit distance to unlock
    LockTTL:             time.Hour,
}
```

| Parameter             | Value     | Description                              |
| --------------------- | --------- | ---------------------------------------- |
| `PasteDeltaThreshold` | 200 chars | Minimum paste size to trigger evaluation |
| `PasteLineThreshold`  | 50 lines  | Alternative line-based threshold         |
| `UnlockThreshold`     | 0.30      | Min edit ratio to unlock (30%)           |
| `LockTTL`             | 1 hour    | Lock expiry after inactivity             |
| LSH `numBands`        | 4         | Number of LSH bands (min 4)              |
| LSH `threshold`       | 10 bits   | Max Hamming distance for similarity      |
| `shingleSize`         | 3 words   | N-gram window for fingerprinting         |

---

## Package Structure

```
ccsignals/
├── .architecture.md      # This document
├── types.go              # Core types, interfaces, and configuration
├── detector.go           # Main detection logic
├── levenshtein.go        # Edit distance calculation
├── simhash.go            # SimHash fingerprinting
├── lsh.go                # LSH indexing + IndexedFingerprintStore (in-memory)
├── redis_store.go        # Redis LockStore implementation
├── memory_store.go       # In-memory LockStore for testing
├── algorave_adapter.go   # ContentValidator for Algorave strudels
├── detector_test.go      # Detector unit tests
├── lsh_test.go           # LSH and indexed store tests
├── simhash_test.go       # SimHash tests
├── levenshtein_test.go   # Edit distance tests
└── types_test.go         # Type and config tests
```

---

## Core Interfaces

```go
// LockStore - storage backend for paste locks (Redis in production)
type LockStore interface {
    SetLock(ctx, sessionID, baselineCode, ttl) error
    GetLock(ctx, sessionID) (*LockState, error)
    RemoveLock(ctx, sessionID) error
    RefreshTTL(ctx, sessionID, ttl) error
}

// ContentValidator - validates content ownership and CC signals
type ContentValidator interface {
    ValidateOwnership(ctx, userID, code) (*ContentMatch, error)
    ValidatePublicContent(ctx, code) (*ContentMatch, error)
}

// IndexedFingerprintStore - in-memory fingerprint index (not an interface)
// Created via NewInMemoryIndexedStore(), loaded from user_strudels at startup
type IndexedFingerprintStore struct {
    index  *LSHIndex
    hasher *SimHasher
}

func (s *IndexedFingerprintStore) AddFromStrudel(workID, creatorID string, ccSignal CCSignal, content string)
func (s *IndexedFingerprintStore) Remove(workID string)
func (s *IndexedFingerprintStore) FindSimilar(content string) []*MatchResult
func (s *IndexedFingerprintStore) FindBestMatch(content string) *MatchResult
```

---

## Usage Example

```go
import "codeberg.org/algorave/server/internal/ccsignals"

// 1. Create lock store (Redis for production, memory for testing)
lockStore := ccsignals.NewRedisLockStore(redisClient)

// 2. Create in-memory fingerprint store with LSH indexing
//    numBands=4, similarityThreshold=10, shingleSize=3
indexedFP := ccsignals.NewInMemoryIndexedStore(4, 10, 3)

// 3. Load no-ai strudels from database at startup
strudels, _ := strudelRepo.ListNoAIStrudels(ctx, 100) // min 100 chars
for _, s := range strudels {
    indexedFP.AddFromStrudel(s.ID, s.UserID, ccsignals.SignalNoAI, s.Code)
}

// 4. Create ContentValidator for ownership checks
validator := ccsignals.NewStrudelValidator(strudelRepo)

// 5. Create detector with all components
config := ccsignals.DefaultConfig()
detector := ccsignals.NewDetector(config, lockStore, validator).
    WithFingerprints(indexedFP)

// 6. In your WebSocket handler:
func handleCodeUpdate(sessionID, userID, oldCode, newCode string) {
    result, _ := detector.DetectPaste(ctx, sessionID, userID, oldCode, newCode)
    if result.ShouldLock {
        detector.SetLock(ctx, sessionID, newCode, config.LockTTL)
    }
}

// 7. In your REST handler (before AI generation):
func handleAIRequest(sessionID string) {
    locked, _ := detector.IsLocked(ctx, sessionID)
    if locked {
        return errors.Forbidden("paste_locked", "...")
    }
    // proceed with AI...
}

// 8. Update index when strudels are created/updated/deleted
func onStrudelCreate(strudel *Strudel) {
    if strudel.CCSignal == "no-ai" {
        indexedFP.AddFromStrudel(strudel.ID, strudel.UserID, ccsignals.SignalNoAI, strudel.Code)
    }
}
func onStrudelDelete(strudelID string) {
    indexedFP.Remove(strudelID)
}
```

---

## Paste Lock Decision Table

| Action                                | Large Delta? | Legitimate Source? | CC Signal          | Result  |
| ------------------------------------- | ------------ | ------------------ | ------------------ | ------- |
| User loads their saved strudel        | Yes          | User owns it       | Any                | No lock |
| User forks public strudel (allows AI) | Yes          | Public strudel     | cc-cr, cc-op, etc. | No lock |
| User forks public strudel (no-ai)     | Yes          | Public strudel     | no-ai              | Locked  |
| User pastes external code             | Yes          | No match           | N/A                | Locked  |
| User types code gradually             | No           | N/A                | N/A                | No lock |
| Fingerprint matches protected work    | Yes          | Similar content    | no-ai              | Locked  |

---

## Performance Expectations

| Operation                  | Latency      | Context                                 |
| -------------------------- | ------------ | --------------------------------------- |
| SimHash generation         | 0.1 - 1 ms   | Per paste event                         |
| LSH bucket lookup          | < 0.1 ms     | Constant regardless of corpus size      |
| Hamming distance check     | < 0.01 ms    | Per candidate in bucket                 |
| Levenshtein (lock release) | 1 - 10 ms    | Between two known strings               |
| **Total detection**        | **1 - 2 ms** | Negligible vs. LLM latency (500-5000ms) |

---

## Future Enhancements

Features not yet implemented that could improve detection:

### Semantic Embedding Layer

Detect paraphrased content using vector similarity instead of lexical fingerprinting.

| Approach                      | Latency      | Catches                   |
| ----------------------------- | ------------ | ------------------------- |
| Local model (ONNX, quantized) | 10 - 50 ms   | Paraphrased content       |
| External API (OpenAI, etc.)   | 100 - 300 ms | High-quality paraphrasing |
| Vector similarity search      | 5 - 20 ms    | Semantic near-duplicates  |

**Trade-off:** Significantly increases latency but catches LLM-paraphrased content that SimHash misses.

### Anomaly Detection

Detect unnatural input patterns that suggest automation or evasion:

- Keystroke timing analysis (detect simulated typing)
- Input velocity anomalies (too fast/too consistent)
- Pattern recognition for chunked pasting

### Audit Logging & Analytics

- Log all detection events, locks, unlocks
- Track false positive/negative rates
- Dashboard for threshold tuning
- Dispute handling workflow

### Client Integrity Checks

- Detect devtools/automation
- Verify paste events originate from real clipboard
- Browser fingerprinting for session validation

### MinHash Alternative

Alternative fingerprinting algorithm with different trade-offs:

- Better for set similarity (Jaccard)
- More robust to insertions/deletions
- Larger storage footprint

---

## Caveats

**This is a speed bump, not a wall.** Any client-side detection can be bypassed. The goal is raising the cost of infringement, not eliminating it.

**Corpus coverage is everything.** You can only detect content you've fingerprinted. Works not in your system won't match.

**Threshold tuning is ongoing.** Both similarity threshold (for matching) and edit threshold (for release) need adjustment based on observed false positives/negatives.

**Paraphrasing defeats lexical fingerprinting.** If users run content through LLMs before pasting, SimHash won't catch it. Semantic embeddings (future enhancement) help but add latency.

**User experience tradeoff.** Locking sessions creates friction. Provide clear messaging and easy dispute paths.

# Notes

Flowcharts & tables on this document created with assistance from llms.
